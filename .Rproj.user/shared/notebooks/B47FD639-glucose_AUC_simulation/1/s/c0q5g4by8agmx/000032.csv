"0","  rho.1.2 <- 0.5"
"0","  rho.1.p <- 0.6"
"0","  rho.max.max <- 0.8"
"0","  rho.max.min <- 0.7"
"0","fake_Rho <- function(p=5,"
"0","                     rho.base.2 = 0.6,"
"0","                     rho.base.p = 0.5,"
"0","                     rho.max.max = 0.8,"
"0","                     rho.max.min = 0.7,"
"0","                     rho.min = 0.5){"
"0","  # rho.base.2 and rho.base.p control the correlations of baseline with post-baseline measures. These tend to be lower than the correlations among post-baseline measures, generally between 0 and 0.5"
"0","  # rho.max.max and rho.max.min control the maximum post-baseline correlations. In general the correlations are highest beteween succeesive times and are highest between final two times, which is rho.max.max. rho.max.min is the correlation between time 2 and 3. The correlations drop to rho.min."
"0","  "
"0","  Rho_fake <- matrix(1, nrow=p, ncol=p)"
"0","  for(i in 1:(p-1)){"
"0","    cells <- p - i"
"0","    row.max <- (cells-1)/(p-2-1)*rho.max.min + (1-(cells-1)/(p-2-1))*rho.max.max"
"0","    inc <- -(row.max - rho.min)/(p - 2 -1)"
"0","    for(j in (i+1):p){"
"0","      if(i==1){"
"0","        Rho_fake[i,j] <- (j-2)/(p-2)*rho.base.p + (1-(j-2)/(p-2))*rho.base.2"
"0","        Rho_fake[j,i] <- Rho_fake[i,j]"
"0","      }else{"
"0","        Rho_fake[i,j] <- row.max + inc*(cells - (p-j+1))"
"0","        Rho_fake[j,i] <- Rho_fake[i,j]"
"0","      }"
"0","    }"
"0","  }"
"0","  return(Rho_fake)"
"0","}"
"0","simulate_it <- function(n=5, mu, beta, Sigma, times, niter=1000, method_list){"
"0","  p_cols <- paste0(method_list, ""_p"")"
"0","  sim_stats_cols <- c(""d_baseline"","
"0","                      ""r.baseline"","
"0","                      ""abs.r.baseline"","
"0","                      ""r.nonbaseline"","
"0","                      ""abs.r.nonbaseline"","
"0","                      p_cols)"
"0","  sim_stats <- matrix(NA, nrow=niter, ncol=length(sim_stats_cols))"
"0","  colnames(sim_stats) <- sim_stats_cols"
"0","  n.times <- length(times)"
"0","  p.clda <- n.times*2 - 2"
"0","  # change names of mu (which will change colnames of Y)"
"0","  names(mu) <- paste0(""glucose"", times)"
"0","  "
"0","  # for Roast and Obrien"
"0","  xcols <- c(""treatment"", ""glucose0"")"
"0","  zcols <- ""treatment"""
"0","  roast_form <- formula(paste('~',paste(xcols,collapse='+'),sep=''))"
"0","  "
"0","  # init fake data matrix"
"0","  fd <- data.table(treatment=factor(rep(c(""cn"", ""tr""), each=n)))"
"0","  fd[, id:=factor(1:.N)]"
"0","  "
"0","  for(iter in 1:niter){"
"0","    Y <- rbind(rmvnorm(n, mu, Sigma),"
"0","               rmvnorm(n, mu+beta, Sigma))"
"0","    fd[, glucose_0 := Y[,1]]"
"0","    #fd[, area := apply(Y, 1, auc, x=times)]"
"0","    fd[, area := apply(Y, 1, trap.rule, x=times)] # faster because compiled?"
"0","    #fd[, area_base := apply(Y, 1, auc, x=times, baseline=TRUE)]"
"0","    fd[, area_base := apply(Y-Y[,1], 1, trap.rule, x=times)]"
"0","    fd[, glucose_mean := apply(Y[,-1], 1, mean)]"
"0","    fd[, glucose_change := glucose_mean - glucose_0]"
"0","    "
"0","    fd_wide <- cbind(fd, Y)"
"0","    fd_long <- melt(fd_wide, id.vars=c(""treatment"", ""id"", ""glucose_0""),"
"0","                      measure.vars = paste0(""glucose"", times),"
"0","                      variable.name = ""time"","
"0","                      value.name = ""glucose"")"
"0","    fd_long[, time:=factor(time)]"
"0","    "
"0","    # get sample correlation"
"0","    fit <- gls(glucose ~ time*treatment,"
"0","               data = fd_long,"
"0","               weights = varIdent(form= ~ 1 | time),"
"0","               correlation= corSymm(form=~ 1| id)"
"0","    )"
"0","    R.sample <- cov2cor(getVarCov(fit, individual=fd_long[1,id]))"
"0","    sim_stats[iter, ""r.baseline""] <- mean(R.sample[2:n.times,1])"
"0","    sim_stats[iter, ""abs.r.baseline""] <- mean(abs(R.sample[2:n.times,1]))"
"0","    R.nonbaseline <- R.sample[2:n.times, 2:n.times]"
"0","    sim_stats[iter, ""r.nonbaseline""] <- mean(R.nonbaseline[lower.tri(R.nonbaseline)])"
"0","    sim_stats[iter, ""abs.r.nonbaseline""] <- mean(abs(R.nonbaseline[lower.tri(R.nonbaseline)]))"
"0","    sim_stats[iter, ""d_baseline""] <- mean(Y[1:n, 1]) - mean(Y[(n+1):(2*n), 1])"
"0","    "
"0","    # p-values"
"0","    if(""lm_area"" %in% method_list){"
"0","      m1 <- lm(area ~ treatment, data=fd)"
"0","      sim_stats[iter, ""lm_area_p""] <- coef(summary(m1))[""treatmenttr"",""Pr(>|t|)""]"
"0","      #sim_stats[iter, ""lm_area_b""] <- coef(m1)[""treatmenttr""]"
"0","    }"
"0","    if(""lm_base"" %in% method_list){"
"0","      m2 <- lm(area_base ~ treatment, data=fd)"
"0","      sim_stats[iter, ""lm_base_p""] <- coef(summary(m2))[""treatmenttr"",""Pr(>|t|)""]"
"0","      #sim_stats[iter, ""lm_base_b""] <- coef(m2)[""treatmenttr""]"
"0","    }"
"0","    if(""lm_cov"" %in% method_list){"
"0","      m3 <- lm(area ~ treatment + glucose_0, data=fd)"
"0","      sim_stats[iter, ""lm_cov_p""] <- coef(summary(m3))[""treatmenttr"",""Pr(>|t|)""]"
"0","      #sim_stats[iter, ""lm_cov_b""] <- coef(m3)[""treatmenttr""]"
"0","    }"
"0","    if(""lm_mean"" %in% method_list){"
"0","      m4 <- lm(glucose_mean ~ treatment, data=fd)"
"0","      sim_stats[iter, ""lm_mean_p""] <- coef(summary(m4))[""treatmenttr"",""Pr(>|t|)""]"
"0","      #sim_stats[iter, ""lm_mean_b""] <- coef(m4)[""treatmenttr""]"
"0","    }"
"0","    if(""lm_mean_cov"" %in% method_list){"
"0","      m5 <- lm(glucose_mean ~ treatment + glucose_0, data=fd)"
"0","      sim_stats[iter, ""lm_mean_cov_p""] <- coef(summary(m5))[""treatmenttr"",""Pr(>|t|)""]"
"0","      #sim_stats[iter, ""lm_mean_cov_b""] <- coef(m5)[""treatmenttr""]"
"0","    }"
"0","    if(""lm_mean_change"" %in% method_list){"
"0","      m6 <- lm(glucose_change ~ treatment, data=fd)"
"0","      sim_stats[iter, ""lm_mean_change_p""] <- coef(summary(m6))[""treatmenttr"",""Pr(>|t|)""]"
"0","      #sim_stats[iter, ""lm_mean_change_b""] <- coef(m6)[""treatmenttr""]"
"0","    }"
"0","    if(""rmanova"" %in% method_list |"
"0","       ""rmanova.i"" %in% method_list |"
"0","       ""rmanova.t"" %in% method_list){"
"0","      # rmanova returns the smallest unadjusted p of the pairs"
"0","      # rmanova.i returns the p for the anova interaction"
"0","      # rmanova.t returns the p for the anova treatment"
"0","      m7 <- aov_4(glucose ~ time*treatment + (time|id),"
"0","                 data=fd_long)"
"0","      if(""rmanova"" %in% method_list){"
"0","        m7.emm <- emmeans(m7,  ~ treatment*time)"
"0","        sim_stats[iter, ""rmanova_p""] <- min(summary(emmeans::contrast(m7.emm, "
"0","                 method = ""revpairwise"","
"0","                 simple = ""each"","
"0","                 combine = TRUE,"
"0","                 adjust = ""none""))[2:n.times, ""p.value""])"
"0","      }"
"0","      if(""rmanova.i"" %in% method_list){"
"0","        sim_stats[iter, ""rmanova.i_p""] <- m7$anova_table[""treatment:time"", ""Pr(>F)""]}"
"0","      if(""rmanova.t"" %in% method_list){"
"0","        sim_stats[iter, ""rmanova.t_p""] <- m7$anova_table[""treatment"", ""Pr(>F)""]}"
"0","    }"
"0","    if(""multi_t"" %in% method_list){"
"0","      Yy <- Y[, -1]"
"0","      fit <- lm(Yy ~ treatment, data=fd_wide)"
"0","      sim_stats[iter, ""multi_t_p""] <- min("
"0","        coefficients(summary(fit))[[1]][""treatmenttr"",""Pr(>|t|)""],"
"0","        coefficients(summary(fit))[[2]][""treatmenttr"",""Pr(>|t|)""],"
"0","        coefficients(summary(fit))[[3]][""treatmenttr"",""Pr(>|t|)""],"
"0","        coefficients(summary(fit))[[4]][""treatmenttr"",""Pr(>|t|)""]"
"0","      )"
"0","      #sim_stats[iter, ""multi_t_b""] <- NA"
"0","    }"
"0","    if(""clda"" %in% method_list){"
"0","      # clda"
"0","#      design <- model.matrix( ~ time + treatment:time, data=fd_long)"
"0","      # remove intercept column and effect of tr at time 0"
"0","#      X <- design[, -c(1, which(colnames(design) == ""timeglucose0:treatmenttr""))]"
"0","            # first check equivalence with single post baseline time"
"0","      check_equivalence <- FALSE"
"0","      if(check_equivalence == TRUE){"
"0","        inc <- which(fd_long$time==""glucose0"" | fd_long$time==""glucose15"")"
"0","        X.check <- design[inc, c(2,7)]"
"0","        m8a <- gls(glucose ~ X.check, # clda"
"0","                   data = fd_long[time==""glucose0"" | time==""glucose15""],"
"0","                   weights = varIdent(form= ~ 1 | time),"
"0","                   correlation= corSymm(form=~ 1| id)"
"0","        )"
"0","        m8b <- lm(glucose ~ glucose_0 + treatment, # ancova-like"
"0","                  data = fd_long[time==""glucose15""]"
"0","        )"
"0","        coef(summary(m8a))"
"0","        coef(summary(m8b))"
"0","        # note that clda has smaller SE."
"0","        # from https://datascienceplus.com/taking-the-baseline-measurement-into-account-constrained-lda-in-r/. By setting weights = varIdent(form = ~ 1 | Time) a separate standard deviation will be estimated for each time point and a seperate correlation will be estimated for each pair of time points (= unstructured variance covariance matrix). By setting weights = varIdent(form = ~ 1 | Time:Group), a separate variance is estimated for each combination of Group and Time (Pre-Exp Post-Exp Pre-Con Post-Con ). The argument correlation=corSymm (form = ~ 1 | Id) defines the subject levels. The correlation structure is assumed to apply only to observations within the same subject (in our example: Id); observations from different subjects (a different value for Id) are assumed to be uncorrelated."
"0","        "
"0","      }"
"0","#      m8 <- gls(glucose ~ X,"
"0","#                 data = fd_long,"
"0","#                 weights = varIdent(form= ~ 1 | time),"
"0","#                 correlation= corSymm(form=~ 1| id))"
"0","      "
"0","      # # an alternative that gives same results. Simply code the interaction columns into a factor"
"0","      fd_clda <- copy(fd_long)"
"0","      fd_clda[, time.treatment := ifelse(time != ""glucose0"" & treatment==""tr"", paste0(time, "":tr""), ""cont"")]"
"0","      fd_clda[, time.treatment := factor(time.treatment, c(""cont"",""glucose15:tr"", ""glucose30:tr"",  ""glucose60:tr"", ""glucose120:tr""))]"
"0","      m8 <- gls(glucose ~ time + time.treatment,"
"0","                 data = fd_clda,"
"0","                 weights = varIdent(form= ~ 1 | time),"
"0","                 correlation= corSymm(form=~ 1| id))"
"0","      "
"0","      r_fit <- cov2cor(getVarCov(m8))"
"0","      r_bar <- mean(r_fit[upper.tri(r_fit)])"
"0","      m <- round(5*n*2/(1 + r_bar*(5-1)), 0)"
"0","      #m8.z <- summary(glht(m8, matrix(c(0, 0,0,0,0,1,1,1,1), 1)))"
"0","      m8.t <- summary(glht(m8, "
"0","                            matrix(c(0, 0,0,0,0,1,1,1,1), 1),"
"0","                            df = m - p.clda))"
"0","      sim_stats[iter, ""clda_p""] <- m8.t$test$pvalues"
"0","      #sim_stats[iter, ""clda_b""] <- m8.t$test$coefficients/4"
"0","    }"
"0","    if(""lda_cov"" %in% method_list){"
"0","      subdata <- fd_long[time != ""glucose0""] # needed for emmeans"
"0","      m9 <- gls(glucose ~ time*treatment + glucose_0,"
"0","                data = subdata,"
"0","                weights = varIdent(form= ~ 1 | time),"
"0","                correlation= corSymm(form=~ 1 | id))"
"0","      # note interaction coefficients are not effects at times 30, 60, 120 "
"0","      # but differences in effect from that at time 15. This is *not* what we want."
"0","      m9.emm <- emmeans(m9, "
"0","                        specs=c(""treatment""),"
"0","  #                      mode = ""boot-satterthwaite"","
"0","                        mode = ""df.error"","
"0","                        data = subdata)"
"0","      m9.trt <- emmeans::contrast(m9.emm, method=""revpairwise"")"
"0","      sim_stats[iter, ""lda_cov_p""] <- summary(m9.trt)[, ""p.value""]"
"0","      #sim_stats[iter, ""lda_cov_b""] <- summary(m9.trt)[, ""estimate""]"
"0","    }"
"0","    if(""roast"" %in% method_list){"
"0","      Yt <- t(Y[, -1]) # responses in rows"
"0","      design <- model.matrix(roast_form, data=fd_wide)"
"0","      colnames(design)[1] <- 'Intercept' # change '(Intercept)' to 'Intercept'"
"0","      prob <- roast(y=Yt,design=design,contrast=2, nrot=2000)$p['UpOrDown','P.Value']"
"0","      sim_stats[iter, ""roast_p""] <- roast(y=Yt,design=design,contrast=2, nrot=2000)$p['UpOrDown','P.Value']"
"0","      #sim_stats[iter, ""roast_b""] <- NA"
"0","      # cont.matrix <- makeContrasts(delta=""zhedonia-zeudaimonia"",levels=design)"
"0","      # prob['delta'] <- roast(y=Yt,design=design,contrast=cont.matrix, nrot=perms)$p['UpOrDown','P.Value']"
"0","    }"
"0","    if(""obrien"" %in% method_list){"
"0","      Yy <- Y[, -1]"
"0","      # design matrix for obrien"
"0","      X2 <- model.matrix(~ glucose0, data=fd_wide)"
"0","      XTXI <- solve(t(X2)%*%X2)"
"0","      fit <- lm.fit(X2, Yy)"
"0","      e <- fit$residuals"
"0","      ranks <- apply(e, 2, rank)"
"0","      ranksum <- apply(ranks, 1, sum)"
"0","      obrien.p <- t.test(ranksum ~ fd_wide$treatment, var.equal=TRUE)$p.value"
"0","      # wilcox.test(ranksum ~ fd_wide$treatment)"
"0","      # rank2 <- apply(e, 1, sum)"
"0","      # wilcox.test(rank2 ~ fd_wide$treatment)"
"0","      "
"0","      sim_stats[iter, ""obrien_p""] <- obrien.p"
"0","      #sim_stats[iter, ""obrien_b""] <- NA"
"0","    }"
"0","  }"
"0","  return(sim_stats)"
"0","}"
"0","simulation_wrapper <- function("
"0","  niter = 1000,"
"0","  n = 5,"
"0","  method_list,"
"0","  times = c(0, 15, 30, 60, 120),"
"0","  gtt_effects = c(0, 1, 1, 1, 0),"
"0","  mu,"
"0","  sigma,"
"0","  cohen_list = c(0, 0.8, 2),"
"0","  cor_models"
"0","){"
"0","  p <- length(times)"
"0","  combis <- expand.grid(cohen = cohen_list, cor_model = 1:nrow(cor_models))"
"0","  for(i in 1:nrow(combis)){"
"0","    cohen <- combis[i, ""cohen""]"
"0","    baseline_max <- cor_models[combis[i, ""cor_model""], ""baseline_max""]"
"0","    non_baseline_max <- cor_models[combis[i, ""cor_model""], ""non_baseline_max""]"
"0","    R <- fake_Rho(p,"
"0","                  rho.base.2 = baseline_max,"
"0","                  rho.base.p = 3/4*baseline_max,"
"0","                  rho.max.max = non_baseline_max,"
"0","                  rho.max.min = 7/8*non_baseline_max,"
"0","                  rho.min = 5/8*non_baseline_max)"
"0","    "
"0","    R_0 <- R[,1] # correlation of each time with time0"
"0","    R_0[1] <- 0 # don't add this component to first beta"
"0","    Sigma <- diag(sigma)%*%R%*%diag(sigma)"
"0","    # total = direct + indirect"
"0","    alpha_1 <- gtt_effects[1]*cohen"
"0","    beta_1 <- R_0*sigma"
"0","    beta <- gtt_effects*cohen*sigma + alpha_1*beta_1"
"0","    "
"0","    sim_stats <- simulate_it(n = n, "
"0","                             mu = mu, "
"0","                             beta = beta, "
"0","                             Sigma = Sigma,"
"0","                             times = times, "
"0","                             niter = niter,"
"0","                             method_list = method_list)"
"0","    "
"0","    res <- rbind(res, data.table(iter = 1:niter,"
"0","                                 effect = cohen,"
"0","                                 baseline_max = baseline_max,"
"0","                                 non_baseline_max = non_baseline_max,"
"0","                                 data.table(sim_stats)))"
"0","  }"
"0","  "
"0","  res[, effect := factor(effect)]"
"0","  res[, baseline_max := factor(baseline_max)]"
"0","  res[, non_baseline_max := factor(non_baseline_max)]"
"0","  return(res)"
"0","}"
